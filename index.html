<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>audioPlayer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./assets/css/normalize.css">

    <style>
        :root{
            --backgroundColor: #008422;
            --pointColor: #008422;
            --trackColor: rgba(255, 255, 255, .7);
            --coverUrl: 'url() no-repeat center;';

            /*사이즈*/
            /*폰트*/
            /*커버url*/
        }


        html, body{
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, var(--backgroundColor),  #fff 70%) no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        *{box-sizing: border-box;}
        .none{display: none;}


        .wrapper{
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            width: 100%;
            max-width: 1272px;
        }

        .player{
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 40px;
            flex-direction: column;
        }

        .time{
            /* width: 100px; */
            text-align: center;
            /* color: rgba(255, 255, 255, .7); */
            font-size: 0.875rem;
            letter-spacing: -.28px;
            font-weight: 500;
            color: var(--pointColor);
        }

        .total-time{
            margin-bottom: 10px;
            opacity: .6;
        }

        .btns1{
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .btn-speed{
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: top;
            width: 40px;
            height: 23px;
            border: 1px solid #cbcbcb;
            border-radius: 5px;
        }

        .info{
            margin-bottom: 16px;
            text-align: center;
        }
        .info h2{
            color: var(--pointColor);
            letter-spacing: -.48px;
            font-size: 1.5rem;
            margin: 0;
            padding: 0;
            margin-bottom: 16px;
            font-weight: bold;
        }
        .info p{
            margin: 0;
            padding: 0;
            color: #222;
            letter-spacing: -.36px;
            font-size: 1.125rem;
        }
        
        .btns2{
            display: flex;
            justify-content: center;
        }
        .btns2 > *{
            margin-right: 50px;
        }
        .btns2 > *:last-child{
            margin-right: 0;
        }
        .btns3{
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        .btns3-wrapper{
            max-width: 1272px;
            width: 100%;
            padding: 26px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .btn-ab{
            border-radius: 12px;
            border: 1px solid transparent;
            padding: 10px 0;
            display: flex;
            align-items: center;
            
        }
        .btn-ab.setting{
            padding: 10px 16px;
            border: 1px solid #ebebeb;
            box-shadow: 1px 1px 2px 0 rgba(0, 0, 0, 0.16);
        }

        .toggle-ab{
            display: none;
            margin-left: 15px;
            border-radius: 100px;
            background: #dbdbdb;
            align-items: center;
            overflow: hidden;
            color: #fff;
        }
        .toggle-ab input{
            display: none;
        }
        .toggle-ab input ~ [data-type="b"]{background: var(--pointColor);}
        .toggle-ab input:checked ~ [data-type="b"]{background: 0}
        .toggle-ab input:checked + [data-type="a"]{background: var(--pointColor);}

        .toggle-ab strong{
            text-align: center;
            width: 40px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 40px;
        }



        .btn-ab.setting .toggle-ab{
            display: flex;
        }

        .btns3-wrapper .side-r{
            display: flex;
        }
        
        .btn-full-screen{
            border-radius: 5px;
            border: 1px solid #cbcbcb;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 38px;
            height: 38px;
            vertical-align: top;
            margin-right: 30px;
        }
        
        .btn-menu{
            border-radius: 5px;
            border: 1px solid #cbcbcb;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 38px;
            height: 38px;
            vertical-align: top;
            flex-direction: column;
        }
        .btn-menu > span{
            display: inline-block;
            vertical-align: top;
            width: 20px;
            height: 2px;
            border-radius: 1px;
            background: #222;
            margin-bottom: 6px;
        }
        
        .btn-menu > span:last-child{
            margin-bottom: 0;
        }

        .btn-play path, .btn-pause rect, svg .handler{fill: var(--pointColor);}
        svg .progress{stroke: var(--pointColor);}
        svg .track{stroke: var(--trackColor);}
        .cover{
            background: var(--coverUrl);
        }

        @media(max-width: 1300px){
            .wrapper{padding: 0 20px;}
            .btns3-wrapper{padding: 12px 20px;}
            
        }
        @media(max-width: 768px){
            /* .wrapper{max-width: 280px;} */
            .btn-full-screen{display: none;}
        }
        @media(max-width: 500px){
            /* .btns2{justify-content: space-between; width: 100%;} */
            .player{margin-bottom: 32px;}
            .time{
                color: rgba(255, 255, 255, .7);
                font-size: 0.6875rem;
                letter-spacing: -.22px;
            }
            .btns1{
                margin-bottom: 24px;
            }
            .info{
                margin-bottom: 12px;
            }
            .info h2{
                font-size: 1rem;
                letter-spacing: -.32px;
                margin-bottom: 12px;
            }
            .info p{
                letter-spacing: -.26px;
                font-size: 0.8125rem;
                line-height: 1.69;
            }
            .btns2 > *{margin-right: 24px;}
        }

        /* @media(max-width: 520px){
            .player{flex-direction: column;}
            .cur-time{order: 2;}
            .player1{order: 1;}
            .total-time{order: 0;}
        } */

        /* .play-btn{fill: red!important;} */

    </style>
</head>
<body>
    <div class="wrapper">
        <div class="player">
            <div id="totalTime" class="time total-time">00 : 00 : 00</div>
            <div id="player1" class="player1"></div>
            <div id="curTime" class="time cur-time">00 : 00 : 00</div>
        </div>
        <div class="btns1">
            <span id="speedBtn" class="btn-speed">1x</span>
            <span id="bookmarkBtn" class="btn-bookmark">
                <img src="./assets/imgs/bookmark.svg">
            </span>
        </div>
        <div id="audioInfo" class="info">
            <h2>하루 한 편 세상에서 가장 짧은 명작 읽기 2</h2>
            <p>2화 - 2회 에밀 아자르 『자기 앞의 생』- 펼쳐진 생이 어떠하든 사랑만 있다면</p>
        </div>
        <div class="btns2">
            <img src="./assets/imgs/prev.svg" onclick="player1.moveAudio('prev');"/>
            <img src="./assets/imgs/prev10.svg" onclick="player1.moveTrack('prev', 10);"/>
            <!-- <img src="./assets/imgs/play.svg" /> -->
            <div onclick="player1.playToggle();">
                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64" id="playBtn" class="btn-play">
                    <g data-name="타원 1" style="stroke:#cbcbcb;stroke-width:1.5px;fill:none">
                        <circle cx="32" cy="32" r="32" style="stroke:none"/>
                        <circle cx="32" cy="32" r="31.25" style="fill:none"/>
                    </g>
                    <path data-name="다각형 1" d="M14.032 2.278a2 2 0 0 1 3.255 0L29.06 18.761a2 2 0 0 1-1.627 3.162H3.886a2 2 0 0 1-1.627-3.162z" transform="rotate(90 14.33 30.67)" />
                </svg>
                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64" id="pauseBtn" class="btn-pause none">
                    <g data-name="타원 1" style="stroke:#cbcbcb;stroke-width:1.5px;fill:none">
                        <circle cx="32" cy="32" r="32" style="stroke:none"/>
                        <circle cx="32" cy="32" r="31.25" style="fill:none"/>
                    </g>
                    <g data-name="그룹 2685" transform="translate(22 18.001)">
                        <rect data-name="사각형 2260" width="8" height="28" rx="1" transform="translate(-1 -.001)" />
                        <rect data-name="사각형 2261" width="8" height="28" rx="1" transform="translate(12.999 -.001)"/>
                    </g>
                </svg>
            </div>
            <img src="./assets/imgs/next10.svg" onclick="player1.moveTrack('next', 10);"/>
            <img src="./assets/imgs/next.svg" onclick="player1.moveAudio('next');"/>
        </div>
        <div class="btns3">
            <div class="btns3-wrapper">
                <div>
                    <span class="btn-ab">
                        <svg xmlns="http://www.w3.org/2000/svg" width="37.66" height="28.808" viewBox="0 0 37.66 28.808" onclick="player1.toggleAB(this);">
                            <g style="opacity:.998; fill:#cbcbcb;">
                                <g data-name="그룹 2710">
                                    <path data-name="패스 709" d="M37.32 36.118h-3.91v-1.694h4.076a9.01 9.01 0 0 0 9-9v-.631a9 9 0 0 0-6.136-8.533v-1.74a11.016 11.016 0 0 1 7.97 10.58v.019a11 11 0 0 1-11 11z" transform="translate(-10.66 -10.849)" />
                                    <path data-name="패스 679" d="M54.1 1001.411a.914.914 0 0 1-.644-.264l-4.172-4.116 4.172-4.116a.917.917 0 1 1 1.287 1.3L51.9 997.03l2.849 2.811a.916.916 0 0 1-.644 1.569z" transform="translate(-28.959 -972.603)" />
                                </g>
                                <g data-name="그룹 2709">
                                    <path data-name="패스 710" d="M44.41 14.52h3.909v1.694h-4.075a9.01 9.01 0 0 0-9 9v.631a9 9 0 0 0 6.137 8.533v1.741a11.016 11.016 0 0 1-7.97-10.579v-.019a11 11 0 0 1 11-11z" transform="translate(-33.411 -10.85)" />
                                    <path data-name="패스 679" d="M50.2 992.65a.914.914 0 0 1 .644.264l4.171 4.116-4.171 4.116a.916.916 0 1 1-1.287-1.3l2.849-2.811-2.849-2.811a.916.916 0 0 1 .644-1.569z" transform="translate(-37.69 -992.519)" />
                                </g>
                                <path data-name="패스 712" d="M-.753-4.246A58.63 58.63 0 0 0-.06-6.908h.055c.231.88.451 1.815.7 2.662l.242.891H-1zM-3.569 0h1.65l.572-2.09h2.64L1.865 0h1.7L.952-8.151H-.963z" transform="translate(21.34 8.151)" />
                                <path data-name="패스 711" d="M-2.745 0h2.9c1.797 0 3.162-.759 3.162-2.4a1.851 1.851 0 0 0-1.53-1.923v-.055A1.847 1.847 0 0 0 2.9-6.138c0-1.518-1.278-2.013-2.95-2.013h-2.695zm1.628-4.829V-6.9h.968c.979 0 1.463.286 1.463 1 0 .649-.451 1.067-1.485 1.067zm0 3.575V-3.63H.016c1.122 0 1.716.341 1.716 1.133 0 .847-.605 1.243-1.716 1.243z" transform="translate(16.024 28.807)" />
                            </g>
                        </svg>
                        <label class="toggle-ab">
                            <input type="checkbox" checked />
                            <strong data-type="a">A</strong>
                            <strong data-type="b">B</strong>
                        </labelb
                    </span>
                </div>
                <div class="side-r">
                    <span id="fullScreenBtn" class="btn-full-screen">
                        <img src="./assets/imgs/bt_fullScreen.svg" />
                    </span>
                    <span id="menuBtn" class="btn-menu">
                        <span></span>
                        <span></span>
                        <span></span>
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const totalTime = document.querySelector('#totalTime');
        const curTime = document.querySelector('#curTime');
        const audioTitle = document.querySelector('#audioInfo h2');
        const audioSubtitle = document.querySelector('#audioInfo p');
        const getRandomNum = (mn, mx) => Math.floor(Math.random() * (mx - mn + 1));
        const toRGB = cde => {
            let r, g, b;
            if(
                cde.indexOf('#') < 0 ||
                cde.indexOf('(') > 0 ||
                cde.indexOf(')') > 0 ||
                cde.indexOf('rgb') > 0
            ){
                cde.split(',').forEach(function(color, idx){
                    let value = '';
                    for(let i = 0; i < color.length; i++){
                        if(!isNaN(color[i]) && color[i] !== ' ') value += color[i];
                    }

                    if(idx === 0) r = +value;
                    else if(idx === 1) g = +value;
                    else if(idx === 2) b = +value;
                })
            }else{
                cde = cde.replace('#', '');
    
                // 3자리 Hex 코드를 6자리로 확장
                if (cde.length === 3) cde = cde[0] + cde[0] + cde[1] + cde[1] + cde[2] + cde[2];
    
                // Hex 값을 R, G, B 값으로 분리
                r = parseInt(cde.substring(0, 2), 16);
                g = parseInt(cde.substring(2, 4), 16);
                b = parseInt(cde.substring(4, 6), 16);
            }

            // RGB 값을 객체로 반환
            return {r, g, b};
        }
        
        const fillZero = (num, digit) =>  num < 10 ** digit ? String(10 ** digit + num).substr(1) : num;    //padStart로 대체 가능
        const sTohhmmss = s =>  `${fillZero(parseInt(s / 360), 2)} : ${fillZero(parseInt(s / 60), 2)} : ${fillZero((Math.round(s) % 60), 2)}`;


        const player1 = new Player1({
            target: '#player1',
            size: 468,
            handlerSize: 16,
            // handlerColor: '#005197',
            // trackColor: 'rgba(255, 255, 255, .5)',
            // progressColor: '#005197',
            progressWidth: 5,
            trackWidth: 3,
            coverMargin: 17,
            coverUrl: './assets/cover/neverEndingStory.jpg',
            audioList: [
                {
                    audioUrl: './assets/audio/neverEndingStory.mp3',
                    title: 'Never Ending Story - 부활',
                    subtitle: '테스트'
                },
                {
                    audioUrl: './assets/audio/jasmine.mp3',
                    title: '말리꽃 - 이승철',
                    subtitle: '테스트'
                }
            ],
            fncPlaying: (info) => { //플레이 중일때 계속 실행
                const target = info.audioList[info.curAudioIdx];
                if(!info.isDowned) curTime.innerHTML = sTohhmmss(target.target.currentTime);

            },
            fncAudioLoad: (info) => {
                const target = info.audioList[info.curAudioIdx];

                totalTime.innerHTML = sTohhmmss(target.target.duration);
                audioTitle.innerHTML = target.title;
                audioSubtitle.innerHTML = target.subtitle;

                info.update({
                    player_color: `rgb(${getRandomNum(0, 255)}, ${getRandomNum(0, 255)}, ${getRandomNum(0, 255)})`
                }, '_', true);
            },
            fncMoveAudio: (info) => {
                const target = info.audioList[info.curAudioIdx];

                curTime.innerHTML = sTohhmmss(target.target.currentTime);
                totalTime.innerHTML = sTohhmmss(target.target.duration);
                audioTitle.innerHTML = target.title;
                audioSubtitle.innerHTML = target.subtitle;

                info.update({
                    cover_src: info.cover.src
                }, '_', true);

                // info.cover.target.style.background = `url(${target.coverUrl}) no-repeat center`;
                // info.cover.target.style.backgroundSize = `cover`;
            },
            fncMoveTrack: (info) => {
                const target = info.audioList[info.curAudioIdx];

                totalTime.innerHTML = sTohhmmss(target.target.duration);
            },
            fncMoveHandler: (info) => {
                const target = info.audioList[info.curAudioIdx];
                const per = info.handler.deg / 360 * 100;

                curTime.innerHTML = sTohhmmss(target.target.duration * per * .01);
            }
        });

        let onceExe = 1;    //resize시 같은범위에 감지

        const resize = () => {
            const w = window.innerWidth;

            if(w < 501){
                if(onceExe !== 'mo'){
                    onceExe = 'mo';
                    player1.update({
                        player_size: 285,
                        handler_size: 10
                    }, '_', true)
                }
                
            }else{
                if(onceExe !== 'pc'){
                    onceExe = 'pc';
                    player1.update({
                        player_size: 468,
                        handler_size: 16
                    }, '_', true)
                }
            }
        }
        // resize();
        window.onresize = resize;

        
        function Player1 (param){
            const t = this;

            const perToDeg = per =>  per * .01 * 360;
            const curOffset = deg => t.player.circumference * (1 - (deg / 360));
            const radianToDeg  = r => r * 180 / Math.PI;
            const degToRadian  = deg => deg * Math.PI / 180;
            const exeFnc = fnc => (fnc && typeof fnc === 'function') ? fnc(t) : '';
            const getDegByDxDy = (x, y) => {
                const centerX = t.player.size * .5;
                const centerY = t.player.size * .5;

                const dx = centerX - x;
                const dy = centerY - y;
                const dxy = Math.sqrt(dx * dx + dy * dy);

                let curDeg = 0;

                if(x > centerX && y < centerY){ //1사분면
                    curDeg = radianToDeg(Math.acos(dy / dxy));
                }else if(x > centerX && y > centerY){   //4사분면
                    curDeg = 90 - radianToDeg(Math.acos(dx/ dxy)) + 180;
                }else if(x < centerX && y < centerY){   //2사분면
                    curDeg = radianToDeg(Math.acos(dx/ dxy)) + 270;
                }else if(x < centerX && y > centerY){   //3사분면
                    curDeg = 90 - radianToDeg(Math.acos(dy / dxy)) + 270;
                }else{
                    if(x > centerX) curDeg = 90;
                    else if(x < centerX) curDeg = 270;
                    else if(y > centerY) curDeg = 180;
                    else if(y < centerY) curDeg = 0;
                }

                // console.log(curDeg);
                return curDeg;
            }

            t.isDowned = false; //마우스 클릭시

            t.raf;

            t.player = {
                size: 0,
                target: '',
                color: ''
            }

            t.cover = {
                size: 0,
                margin: 0,
                src: ''
            }

            t.a = {

            }

            t.b = {

            }

            t.abTrack = {
                target: '',
                radius: 0,
                width: 0,
                cx: 0,
                cy: 0,
                a: 0,
                b: 0
            }

            t.abSection = {
                target: ''
            }

            t.track = {
                target: '',
                radius: 0,
                width: 0,
                cx: 0,
                cy: 0,
                strokeWidth: 0
            }
            
            t.progress = {
                target: '',
                radius: 0,
                width: 0,
                cx: 0,
                cy: 0,
                a: 0,
                b: 0,
                deg: 0,
                strokeWidth: 0
            }

            t.handler = {
                target: '',
                size: 0,
                deg: 0,
                cx: 0,
                cy: 0,
                strokeWidth: 0
            }


            t.startTick = {}

            t.change = [];

            t.audioList = [];

            t.curAudioIdx = 0;

            


            t.update = (obj, separator, ui) => {
                t.change.length = 0;

                for(let key in obj){
                    const keyNm = key.split(separator);

                    const key1 = keyNm[0];
                    const key2 = keyNm[1];

                    t[key1][key2] = obj[key];
                    t.change.push(key);

                    if(key1 === 'player'){
                        if(key2 === 'size'){

                            t.player.size = obj[key];

                            const playerHalfSize = t.player.size * .5;
                            const handlerHalfSize = t.handler.size * .5;
                            const calced = val => val * t.track.radius + playerHalfSize;

                            // t.player.circumference = 2 * Math.PI * ((playerHalfSize - handlerHalfSize) - (t.progress.width));
                            t.player.circumference = 2 * Math.PI * (playerHalfSize - handlerHalfSize);

                            t.progress.cx = playerHalfSize;
                            t.progress.cy = playerHalfSize;
                            t.progress.radius = (playerHalfSize) - handlerHalfSize;

                            t.track.cx = playerHalfSize;
                            t.track.cy = playerHalfSize;
                            t.track.radius = playerHalfSize - handlerHalfSize;

                            t.handler.cx = calced(Math.sin(degToRadian(t.handler.deg)));
                            t.handler.cy = t.player.size - calced(Math.cos(degToRadian(t.handler.deg)));
                        }
                        
                    }

                    if(key1 === 'handler'){
                        if(key2 === 'size'){
                            t.handler.size = obj[key];

                            const playerHalfSize = t.player.size * .5;
                            const handlerHalfSize = t.handler.size * .5;
                            const calced = val => val * t.track.radius + playerHalfSize;

                            t.player.circumference = 2 * Math.PI * (playerHalfSize - handlerHalfSize);
                            t.progress.radius = (playerHalfSize) - handlerHalfSize;
                            t.track.radius = playerHalfSize - handlerHalfSize;

                            t.handler.cx = calced(Math.sin(degToRadian(t.handler.deg)));
                            t.handler.cy = t.player.size - calced(Math.cos(degToRadian(t.handler.deg)));
                        }else if(key2 === 'deg'){
                            const playerHalfSize = t.player.size * .5;
                            const calced = val => val * t.track.radius + playerHalfSize;

                            t.handler.deg = obj[key];
                            t.handler.cx = calced(Math.sin(degToRadian(obj[key])));
                            t.handler.cy = t.player.size - calced(Math.cos(degToRadian(obj[key])));
                        }
                    }

                    if(key1 === 'progress'){
                        if(key2 === 'deg'){
                            t.progress.deg = obj[key];
                        }
                    }


                }

                if(ui) t.updateUI(separator);
            }

            t.updateUI = (s) => {
                t.change.forEach((k) => {
                    const keyNm = k.split(s);

                    const key1 = keyNm[0];
                    const key2 = keyNm[1];
                    
                    if(key1 === 'player'){
                        if(key2 === 'size'){
                            const playerHalfSize = t.player.size * .5;
                            const handlerHalfSize = t.handler.size * .5;
                            const imgSize = t.player.size - (t.cover.margin * 2) - t.handler.size;
                            const imgOffset = t.cover.margin + (t.handler.size * .5);

                            document.querySelector('svg[data-type="svg"]').style.cssText = `
                                width: ${t.player.size}px;
                                height: ${t.player.size}px;
                                vertical-align: top;
                            `;

                            t.cover.target.style.width = `${imgSize}px`;
                            t.cover.target.style.height = `${imgSize}px`;
                            t.cover.target.style.top = `${imgOffset}px`;
                            t.cover.target.style.bottom = `${imgOffset}px`;

                            t.track.target.setAttribute('cx', t.track.cx);
                            t.track.target.setAttribute('cy', t.track.cy);
                            t.track.target.setAttribute('r', t.track.radius);

                            t.progress.target.setAttribute('cx', t.progress.cx);
                            t.progress.target.setAttribute('cy', t.progress.cy);
                            t.progress.target.setAttribute('r', t.progress.radius);
                            t.progress.target.setAttribute('stroke-dasharray', t.player.circumference);
                            t.progress.target.setAttribute('stroke-dashoffset', curOffset(t.progress.deg));

                            t.handler.target.setAttribute('cx', t.handler.cx);
                            t.handler.target.setAttribute('cy', t.handler.cy);
                            t.handler.target.setAttribute('r', t.handler.size * .5);
                        } else if(key2 === 'color'){
                            const color = toRGB(t.player.color);
                            let overAll120 = true;
                            let sub120 = 0;
                            for(let key in color){
                                if(color[key] < 120){
                                    overAll120 = false;
                                    sub120++;
                                }else{
                                    color[key] = color[key] - 100;
                                }
                            }

                            if(overAll120){
                                totalTime.style.cssText = '';
                            }else{
                                if(sub120 === 3){
                                    totalTime.style.cssText = `
                                        color: var(--trackColor);
                                        opacity: 1'
                                    `;
                                }
                            }

                            document.documentElement.style.setProperty('--backgroundColor', t.player.color);
                            document.documentElement.style.setProperty('--pointColor', `rgb(${(color.r)}, ${(color.g)}, ${(color.b)})`);
                            // document.documentElement.style.setProperty('--trackColor', '#fff');
                        }
                    }

                    if(key1 === 'handler'){
                        if(key2 === 'size'){
                            t.progress.target.setAttribute('r', t.progress.radius);
                            t.track.target.setAttribute('r', t.track.radius);

                            t.handler.target.setAttribute('cx', t.handler.cx);
                            t.handler.target.setAttribute('cy', t.handler.cy);
                            t.handler.target.setAttribute('r', t.handler.size * .5);
                        }else if(key2 === 'deg'){
                            t.handler.target.setAttribute('cx', t.handler.cx);
                            t.handler.target.setAttribute('cy', t.handler.cy);
                        }
                    };

                    if(key1 === 'progress'){
                        if(key2 === 'deg'){
                            t.progress.target.setAttribute('stroke-dashoffset', curOffset(t.progress.deg));
                            return true;
                        }
                    }
                    
                    if(key1 === 'cover'){
                        if(key2 === 'src'){
                            document.documentElement.style.setProperty('--coverUrl', `url(${t.cover.src}) no-repeat center`);
                        }
                    }

                })
            }

            function constructor(){
                setData();
                function setData(){
                    t.player.target = document.querySelector(param.target);
                    t.player.size = param.size;
                    // t.player.circumference = 2 * Math.PI * ((t.player.size * .5 - param.handlerSize * .5) - (t.progress.width));
                    t.player.circumference = 2 * Math.PI * ((t.player.size * .5 - param.handlerSize * .5));
    
                    t.cover.target = document.createElement('div');
                    t.cover.src = param.coverUrl;
                    t.cover.margin = param.coverMargin;
    
                    t.handler.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.handler.size = param.handlerSize;

                    t.progress.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.progress.cx = param.size * .5;
                    t.progress.cy = param.size * .5;
                    t.progress.width = param.progressWidth;
                    t.progress.radius = (param.size * .5) - (t.handler.size * .5);
                    
                    t.track.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.track.cx = param.size * .5;
                    t.track.cy = param.size * .5;
                    t.track.width = param.trackWidth;
                    t.track.radius = (param.size * .5) - (t.handler.size * .5);


                    t.a.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.b.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.abTrack.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.abSection.target = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    t.startTick.target = document.createElementNS("http://www.w3.org/2000/svg", "rect");


                    //오디오 영역
                    let allAudioReady = 0;

                    param.audioList.forEach((audio, idx) => {
                        const newAudio = new Audio(audio.audioUrl);

                        newAudio.onloadeddata = () => {
                            t.audioList[idx] = {
                                idx: idx,
                                target: newAudio,
                                title: audio.title,
                                subtitle: audio.subtitle
                            }

                            allAudioReady++;
                            if(param.audioList.length == allAudioReady){
                                // console.log(idx, '성공');

                                exeFnc(param.fncAudioLoad);

                                setUI();
                                resize();
                                allAudioReady = 0;
                            }
                        }
                    });
                }

                // setUI();

                function setUI(){
                    t.player.target.style.cssText = `position: relative;`;

                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.dataset.type = 'svg';
                    svg.style.cssText = `
                        width: ${t.player.size}px;
                        height: ${t.player.size}px;
                        vertical-align: top;
                    `;

                    const imgSize = t.player.size - (t.cover.margin * 2) - t.handler.size;
                    const imgOffset = t.cover.margin + (t.handler.size * .5);
                    t.cover.target.classList.add('cover');
                    t.cover.target.style.cssText = `
                        background-size: cover;
                        width: ${imgSize}px;
                        height: ${imgSize}px;
                        border-radius: 50%;
                        position: absolute;
                        top: ${imgOffset}px;
                        left: ${imgOffset}px;
                    `;

                    document.documentElement.style.setProperty('--coverUrl', `url(${t.cover.src}) no-repeat center`);

                    t.track.target.classList.add('track');
                    t.track.target.setAttribute('cx', t.track.cx);
                    t.track.target.setAttribute('cy', t.track.cy);
                    t.track.target.setAttribute('r', t.track.radius);
                    t.track.target.setAttribute('fill', 'none');
                    t.track.target.setAttribute('stroke-width', t.track.width);

                    t.progress.target.classList.add('progress');
                    t.progress.target.setAttribute('cx', t.progress.cx);
                    t.progress.target.setAttribute('cy', t.progress.cx);
                    t.progress.target.setAttribute('r', t.progress.radius);
                    t.progress.target.setAttribute('fill', 'none');
                    t.progress.target.style.transform = 'rotate(-90deg)';
                    t.progress.target.style.transformOrigin = '50%';
                    t.progress.target.setAttribute('stroke-width', t.progress.width);
                    t.progress.target.setAttribute('stroke-linecap', 'round');
                    t.progress.target.setAttribute('stroke-dasharray', t.player.circumference);
                    t.progress.target.setAttribute('stroke-dashoffset', curOffset(0));


                    t.handler.target.classList.add('handler');
                    t.handler.target.setAttribute('cx', t.player.size * .5);
                    t.handler.target.setAttribute('cy', t.handler.size * .5);
                    t.handler.target.setAttribute('r', t.handler.size * .5);

                    svg.appendChild(t.track.target);
                    svg.appendChild(t.progress.target);
                    svg.appendChild(t.handler.target);
    
                    t.player.target.appendChild(t.cover.target);
                    t.player.target.appendChild(svg);
                }

                setFnc();
                function setFnc(){
                    t.player.target.removeEventListener('mousedown', fnc_mouseDownEvent);
                    t.player.target.removeEventListener('mousemove', fnc_mouseMoveEvent);
                    t.player.target.removeEventListener('mouseup', fnc_mouseUpEvent);
                    t.player.target.removeEventListener('touchstart', fnc_mouseDownEvent);
                    t.player.target.removeEventListener('touchmove', fnc_mouseMoveEvent);
                    t.player.target.removeEventListener('touchend', fnc_mouseUpEvent);

                    t.player.target.addEventListener('mousedown', fnc_mouseDownEvent);
                    t.player.target.addEventListener('mousemove', fnc_mouseMoveEvent);
                    t.player.target.addEventListener('mouseup', fnc_mouseUpEvent);
                    t.player.target.addEventListener('touchstart', fnc_mouseDownEvent);
                    t.player.target.addEventListener('touchmove', fnc_mouseMoveEvent);
                    t.player.target.addEventListener('touchend', fnc_mouseUpEvent);


                    function fnc_mouseDownEvent(e){
                        t.isDowned = true;
                    }

                    function fnc_mouseMoveEvent(e){
                        e.preventDefault();
                        if(!t.isDowned) return;

                        const xy = t.player.target.getBoundingClientRect();
                        const x = e.touches ? e.touches[0].clientX - xy.x : e.offsetX;
                        const y = e.touches ? e.touches[0].clientY - xy.y : e.offsetY;
                        const deg = getDegByDxDy(x, y);

                        t.update({handler_deg: deg}, '_', true);

                        exeFnc(param.fncMoveHandler);
                    }

                    function fnc_mouseUpEvent(e){
                        e.preventDefault();
                        if(!t.isDowned) return;

                        const xy = t.player.target.getBoundingClientRect();
                        const x = e.changedTouches ? e.changedTouches[0].clientX - xy.x : e.offsetX;
                        const y = e.changedTouches ? e.changedTouches[0].clientY - xy.y : e.offsetY;

                        const deg = getDegByDxDy(x, y);
                        const percent = deg / 360 * 100;

                        const target = t.audioList[t.curAudioIdx].target;

                        target.currentTime = target.duration * percent * .01;

                        t.isDowned = false;

                        t.update({progress_deg: deg}, '_', true);
                        if(t.isDowned) return;
                        t.update({handler_deg: deg}, '_', true);
                    }

                }
            }
            
            constructor();

            // t.play = () => {
            //     const target = t.audioList[t.curAudioIdx];
            //     target.play();
            // }

            

            t.playToggle = (bool) => {
                const target = t.audioList[t.curAudioIdx].target;
                const toggleBase = bool === undefined ? target.paused : bool;
                target[toggleBase ? 'play' : 'pause']();

                target.paused ? window.cancelAnimationFrame(t.raf) : t.playing();
                
                document.querySelector('#playBtn').classList[target.paused ? 'remove' : 'add']('none');
                document.querySelector('#pauseBtn').classList[target.paused ? 'add' : 'remove']('none');
            }


            t.playing = () => {
                const target = t.audioList[t.curAudioIdx].target;
                const deg = perToDeg(target.currentTime / target.duration * 100);

                t.update({
                    progress_deg: deg
                }, '_', true)
                
                if(!t.isDowned){
                    t.update({
                        handler_deg: deg
                    }, '_', true)
                };

                exeFnc(param.fncPlaying);
                
                t.raf = window.requestAnimationFrame(t.playing);

            }

            t.moveTrack = (dir, sec) => {
                const target = t.audioList[t.curAudioIdx].target;

                target.currentTime = target.currentTime + (sec * (dir === 'next' ? 1 : -1));
                if(target.currentTime < 0) target.currentTime = 0;
                if(target.currentTime > target.duration) target.currentTime = target.duration;

                const deg = perToDeg(target.currentTime / target.duration * 100);

                t.update({
                    progress_deg: deg,
                    handler_deg: deg
                }, '_', true);

                exeFnc(param.fncMoveTrack);
            }

            t.moveAudio = (dir) => {
                const target = t.audioList[t.curAudioIdx].target;

                const isPlaying = !target.paused;

                if(target.currentTime  > 5){ //다시듣기
                    target.currentTime = 0;

                    t.update({
                        progress_deg: 0,
                        handler_deg: 0
                    }, '_', true);

                    exeFnc(param.fncMoveAudio);

                    return;
                }

                t.playToggle(false);
                target.currentTime = 0;

                t.update({
                    progress_deg: 0,
                    handler_deg: 0
                }, '_', true);

                t.curAudioIdx = t.curAudioIdx + (1 * (dir === 'next' ? 1 : -1));
                if(t.curAudioIdx < 0) t.curAudioIdx = t.audioList.length - 1;
                if(t.curAudioIdx > t.audioList.length - 1) t.curAudioIdx = 0;

                const target2 = t.audioList[t.curAudioIdx].target;
                if(isPlaying) t.playToggle(true);

                exeFnc(param.fncMoveAudio);
            }

            let toggleCnt = 0;

            t.toggleAB = (e) => {
                toggleCnt++;
                if(toggleCnt > 2) toggleCnt = 0;

                e.querySelector(':scope > g').style.fill = toggleCnt === 2 ? 'var(--pointColor)' : '#cbcbcb';
                e.closest('span').classList[toggleCnt === 1 ? 'add' : 'remove']('setting');
            }
        }

    </script>
</body>
</html>